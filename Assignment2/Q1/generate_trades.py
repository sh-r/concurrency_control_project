#!/usr/bin/env python3
"""
generate_trades.py

Generates a trade table with fractally distributed stock symbols and writes
it to a CSV file trades_10M.csv with schema:

    stocksymbol, time, quantity, price

Conforms to the assignment spec:
- 100,000 fractally distributed stock symbols generated by gen(0.3, 70000)
- 10,000,000 trades
- time is unique per trade (1..10_000_000)
- quantity uniformly in [100, 10_000]
- price in [50, 500], successive prices per symbol differ by 1..5
"""

import csv
import random
import time
from typing import List



def gen(frac: float, N: int) -> List[int]:
    """
    Generate a fractal distribution of integers 1..N.

    Pseudocode (from assignment):

        p := random permutation of numbers from 1 to N
        outvec := p
        while |p| > 1:
            p := first floor(frac * |p|) elements of p
            prepend p to outvec
        return random permutation of outvec
    """
    p = list(range(1, N + 1))
    random.shuffle(p)

    outvec = p.copy()

    while len(p) > 1:
        k = int(frac * len(p))  # floor func
        if k < 1:
            break
        p = p[:k]
        outvec = p + outvec

    random.shuffle(outvec)
    return outvec


def make_fractal_symbol_pool(
    frac: float = 0.3,
    base_N: int = 70_000,
    pool_size: int = 100_000,
) -> List[str]:
    """
    Use gen(frac, base_N) to produce an array of stock symbols
    with fractal probabilities, then cut/extend it to exactly `pool_size`.
    Each integer i is mapped to a symbol "s{i}".
    """
    raw = gen(frac, base_N)

    if len(raw) >= pool_size:
        raw = raw[:pool_size]
    else:
        needed = pool_size - len(raw)
        raw = raw + raw[:needed]

    symbols = [f"s{i}" for i in raw]
    return symbols



def choose_next_price(prev_price: int) -> int:
    """
    Given previous price in [50, 500], choose a new integer price such that:
    - It remains within [50, 500]
    - It differs from prev_price by at least 1 and at most 5
    """
    MIN_PRICE = 50
    MAX_PRICE = 500

    low = max(MIN_PRICE, prev_price - 5)
    high = min(MAX_PRICE, prev_price + 5)

    candidates = [p for p in range(low, high + 1) if p != prev_price]
    return random.choice(candidates)


def generate_trades_to_csv(
    output_path: str = "trades_10M.csv",
    num_trades: int = 10_000_000,
    frac: float = 0.3,
    base_N: int = 70_000,
    pool_size: int = 100_000,
    seed: int = 42,
) -> None:
    """
    Generate trades and stream them to a CSV file.

    Columns: stocksymbol, time, quantity, price
    """
    random.seed(seed)

    print("Generating fractal symbol pool...")
    symbols_pool = make_fractal_symbol_pool(frac=frac, base_N=base_N, pool_size=pool_size)
    pool_len = len(symbols_pool)
    print(f"Symbol pool size: {pool_len} (expected 100000)")

    last_price = {}  # per-symbol last price

    print(f"Writing {num_trades:,} trades to {output_path} ...")
    start_time = time.time()

    with open(output_path, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["stocksymbol", "time", "quantity", "price"])

        for t in range(1, num_trades + 1):
            idx = random.randrange(pool_len)
            symbol = symbols_pool[idx]

            quantity = random.randint(100, 10_000)

            if symbol not in last_price:
                price = random.randint(50, 500)
            else:
                price = choose_next_price(last_price[symbol])

            last_price[symbol] = price

            writer.writerow([symbol, t, quantity, price])

            if t % 1_000_000 == 0:
                elapsed = time.time() - start_time
                print(f"  {t:,} trades written (elapsed {elapsed:.1f} s)")

    total_elapsed = time.time() - start_time
    print(f"Finished writing {num_trades:,} trades in {total_elapsed:.1f} s.")
    print(f"Output file: {output_path}")


def main():
    generate_trades_to_csv()


if __name__ == "__main__":
    main()
